package class038;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

// ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„ç»„åˆ
// ç­”æ¡ˆ ä¸èƒ½ åŒ…å«é‡å¤çš„ç»„åˆã€‚è¿”å›çš„ç­”æ¡ˆä¸­ï¼Œç»„åˆå¯ä»¥æŒ‰ ä»»æ„é¡ºåº æ’åˆ—
// æ³¨æ„å…¶å®è¦æ±‚è¿”å›çš„ä¸æ˜¯å­é›†ï¼Œå› ä¸ºå­é›†ä¸€å®šæ˜¯ä¸åŒ…å«ç›¸åŒå…ƒç´ çš„ï¼Œè¦è¿”å›çš„å…¶å®æ˜¯ä¸é‡å¤çš„ç»„åˆ
// æ¯”å¦‚è¾“å…¥ï¼šnums = [1,2,2]
// è¾“å‡ºï¼š[[],[1],[1,2],[1,2,2],[2],[2,2]]
// æµ‹è¯•é“¾æ¥ : https://leetcode.cn/problems/subsets-ii/
public class Code02_Combinations {
//time O(2^N) space O(N)
	public static List<List<Integer>> subsetsWithDup(int[] nums) {
		List<List<Integer>> ans = new ArrayList<>();
		Arrays.sort(nums);
		f(nums, 0, new int[nums.length], 0, ans);
		return ans;
	}

	public static void f(int[] nums, int i, int[] path, int size, List<List<Integer>> ans) {
		if (i == nums.length) {
			ArrayList<Integer> cur = new ArrayList<>();
			for (int j = 0; j < size; j++) {
				cur.add(path[j]);
			}
			ans.add(cur);
		} else {
			// ä¸‹ä¸€ç»„çš„ç¬¬ä¸€ä¸ªæ•°çš„ä½ç½®
			int j = i + 1;
			while (j < nums.length && nums[i] == nums[j]) {
				j++;
			}
			// å½“å‰æ•°xï¼Œè¦0ä¸ª
			f(nums, j, path, size, ans);
			// å½“å‰æ•°xï¼Œè¦1ä¸ªã€è¦2ä¸ªã€è¦3ä¸ª...éƒ½å°è¯•
			for (; i < j; i++) {
				path[size++] = nums[i];
				f(nums, j, path, size, ans);
			}
		}
	}

}

// å½“å‰æ•°xï¼Œè¦0ä¸ª
f(nums, j, path, size, ans);

// å½“å‰æ•°xï¼Œè¦1ä¸ªã€è¦2ä¸ªã€è¦3ä¸ª...
for (; i < j; i++) {
    path[size++] = nums[i];
    f(nums, j, path, size, ans);
}
```

**å«ä¹‰**:
```
å¯¹äºå½“å‰ç»„ [i, j) çš„å…ƒç´ ï¼š

åˆ†æ”¯1: è¦ 0 ä¸ª
  â†’ ç›´æ¥è·³åˆ° jï¼ˆä¸‹ä¸€ç»„ï¼‰

åˆ†æ”¯2: è¦ 1 ä¸ª
  â†’ åŠ å…¥ 1 ä¸ªï¼Œè·³åˆ° j

åˆ†æ”¯3: è¦ 2 ä¸ª
  â†’ åŠ å…¥ 2 ä¸ªï¼Œè·³åˆ° j

...
```

---

## ğŸ¬ å®Œæ•´æ‰§è¡Œè¿‡ç¨‹

### è¾“å…¥: nums = [1, 2, 2] (å·²æ’åº)
```
f(nums, i=0, path=[], size=0)
â”œâ”€ i=0, nums[0]=1
â”‚  j=1 (1åªæœ‰1ä¸ª)
â”‚
â”‚  â”œâ”€ è¦ 0 ä¸ª 1:
â”‚  â”‚  f(nums, j=1, path=[], size=0)
â”‚  â”‚  â”œâ”€ i=1, nums[1]=2
â”‚  â”‚  â”‚  j=3 (2æœ‰2ä¸ª)
â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”œâ”€ è¦ 0 ä¸ª 2:
â”‚  â”‚  â”‚  â”‚  f(nums, j=3, path=[], size=0)
â”‚  â”‚  â”‚  â”‚  â†’ i==3, æ”¶é›† [] âœ…
â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”œâ”€ è¦ 1 ä¸ª 2:
â”‚  â”‚  â”‚  â”‚  path[0]=2, size=1
â”‚  â”‚  â”‚  â”‚  f(nums, j=3, path=[2], size=1)
â”‚  â”‚  â”‚  â”‚  â†’ i==3, æ”¶é›† [2] âœ…
â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€ è¦ 2 ä¸ª 2:
â”‚  â”‚  â”‚     path[1]=2, size=2
â”‚  â”‚  â”‚     f(nums, j=3, path=[2,2], size=2)
â”‚  â”‚  â”‚     â†’ i==3, æ”¶é›† [2,2] âœ…
â”‚  â”‚
â”‚  â”œâ”€ è¦ 1 ä¸ª 1:
â”‚  â”‚  path[0]=1, size=1
â”‚  â”‚  f(nums, j=1, path=[1], size=1)
â”‚  â”‚  â”œâ”€ i=1, nums[1]=2
â”‚  â”‚  â”‚  j=3
â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”œâ”€ è¦ 0 ä¸ª 2:
â”‚  â”‚  â”‚  â”‚  f(nums, j=3, path=[1], size=1)
â”‚  â”‚  â”‚  â”‚  â†’ i==3, æ”¶é›† [1] âœ…
â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â”œâ”€ è¦ 1 ä¸ª 2:
â”‚  â”‚  â”‚  â”‚  path[1]=2, size=2
â”‚  â”‚  â”‚  â”‚  f(nums, j=3, path=[1,2], size=2)
â”‚  â”‚  â”‚  â”‚  â†’ i==3, æ”¶é›† [1,2] âœ…
â”‚  â”‚  â”‚  â”‚
â”‚  â”‚  â”‚  â””â”€ è¦ 2 ä¸ª 2:
â”‚  â”‚  â”‚     path[2]=2, size=3
â”‚  â”‚  â”‚     f(nums, j=3, path=[1,2,2], size=3)
â”‚  â”‚  â”‚     â†’ i==3, æ”¶é›† [1,2,2] âœ…

ç»“æœ: [[], [2], [2,2], [1], [1,2], [1,2,2]]
```

---

## ğŸ¤” ä¸ºä»€ä¹ˆéš¾ç†è§£ï¼Ÿ

### 1. å¿ƒæ™ºæ¨¡å‹ä¸åŒ

**äºŒå‰æ ‘æ¨¡å‹ï¼ˆç›´è§‚ï¼‰**:
```
æ¯ä¸ªå…ƒç´ ï¼šé€‰ or ä¸é€‰
â†’ ç¬¦åˆäººçš„æ€ç»´ä¹ æƒ¯
```

**å¤šå‰æ ‘æ¨¡å‹ï¼ˆè¿™ä¸ªå†™æ³•ï¼‰**:
```
æ¯ç»„å…ƒç´ ï¼šè¦å‡ ä¸ªï¼Ÿ
â†’ éœ€è¦"åˆ†ç»„"çš„æŠ½è±¡æ€ç»´



90. Subsets II. https://leetcode.com/problems/subsets-ii/description/
Given an integer array nums that may contain duplicates, return all possible subsets (the power set).

The solution set must not contain duplicate subsets. Return the solution in any order.

class Solution {
    List<List<Integer>> res;
    List<Integer> path;
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        res = new ArrayList<>();
        path = new ArrayList<>();
        dfs(nums, 0);
        return res;
    }
    private void dfs(int[] nums, int start) {
        if (start == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }

        path.add(nums[start]);
        dfs(nums, start + 1);
        path.remove(path.size() - 1);

        int next = start + 1;
        while (next < nums.length && nums[next] == nums[start]) {
            next++;
        }
        dfs(nums, next);
    }
}

## ğŸ¤” ä¸ºä»€ä¹ˆ"é€‰"çš„æ—¶å€™ä¸éœ€è¦è·³è¿‡ï¼Ÿ

### å…³é”®ç†è§£ï¼šä½ç½®çš„åŒºåˆ†ä½œç”¨
```
[1, 2â‚, 2â‚‚]

å½“æˆ‘ä»¬"é€‰ 2â‚"æ—¶:
  - æˆ‘ä»¬æ˜ç¡®é€‰çš„æ˜¯ä½ç½®1çš„å…ƒç´ 
  - æ¥ä¸‹æ¥è€ƒè™‘ä½ç½®2çš„å…ƒç´ ï¼ˆ2â‚‚ï¼‰
  - è™½ç„¶å€¼ç›¸åŒï¼Œä½†ä½ç½®ä¸åŒï¼Œå¯ä»¥ç»§ç»­å¤„ç†

å½“æˆ‘ä»¬"ä¸é€‰ 2â‚"æ—¶:
  - å¦‚æœä¸è·³è¿‡ï¼Œä¼šåœ¨ä½ç½®2é€‰ 2â‚‚
  - è¿™ä¼šå¯¼è‡´ [1, 2â‚] å’Œ [1, 2â‚‚] é‡å¤
  - æ‰€ä»¥å¿…é¡»è·³è¿‡æ‰€æœ‰ç›¸åŒçš„ï¼
```

---

## ğŸ“Š ç”¨é›†åˆç†è§£

### é€‰æ‹©çš„æœ¬è´¨
```
nums = [1, 2â‚, 2â‚‚]

æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©æ–¹æ¡ˆ:
1. ä¸é€‰ä»»ä½• 2 â†’ []
2. é€‰ 2â‚ ä¸é€‰ 2â‚‚ â†’ [2â‚]
3. ä¸é€‰ 2â‚ é€‰ 2â‚‚ â†’ [2â‚‚]  â† è¿™ä¸ªå’Œæ–¹æ¡ˆ2é‡å¤ï¼
4. é€‰ 2â‚ é€‰ 2â‚‚ â†’ [2â‚,2â‚‚]

å»é‡è§„åˆ™ï¼š
- å¦‚æœä¸é€‰ 2â‚ï¼Œå°±ä¸èƒ½é€‰ 2â‚‚
- è¿™æ ·æ–¹æ¡ˆ3å°±è¢«æ¶ˆé™¤äº†
```

---

## ğŸ’¡ å¦ä¸€ç§ç†è§£æ–¹å¼ï¼šç»Ÿä¸€å¤„ç†ç›¸åŒå…ƒç´ 
```
æŠŠè¿ç»­ç›¸åŒçš„å…ƒç´ çœ‹ä½œä¸€ä¸ªæ•´ä½“:

[1, 2, 2, 3]
    â””â”€â”€â”˜
   å½“ä½œä¸€ä¸ª"å•å…ƒ"

å¯¹äºè¿™ä¸ª"å•å…ƒ"ï¼Œæœ‰3ç§é€‰æ‹©:
1. ä¸é€‰ä»»ä½•ä¸€ä¸ª
2. é€‰1ä¸ªï¼ˆç¬¬ä¸€ä¸ªï¼‰
3. é€‰2ä¸ªï¼ˆéƒ½é€‰ï¼‰

ä»£ç ä¸­çš„é€»è¾‘:
- "é€‰"åˆ†æ”¯ï¼šå¤„ç†é€‰1ä¸ªã€é€‰2ä¸ª...
- "ä¸é€‰"åˆ†æ”¯ï¼šå¤„ç†ä¸é€‰ä»»ä½•ä¸€ä¸ªï¼ˆè·³è¿‡æ•´ä¸ªå•å…ƒï¼‰
```

---

## ğŸ¯ è®°å¿†æŠ€å·§

### å£è¯€
```
é€‰äº†é€’å½’æ­£å¸¸èµ°ï¼Œ
ä¸é€‰è·³è¿‡æ‰€æœ‰ç›¸åŒã€‚
```

### ä¸ºä»€ä¹ˆï¼Ÿ
```
é€‰: æˆ‘æ‰¿è¯ºç”¨è¿™ä¸ªå…ƒç´ ï¼Œåé¢çš„ç›¸åŒå…ƒç´ å¯ä»¥å†é€‰
ä¸é€‰: æˆ‘æ”¾å¼ƒè¿™ä¸ªå…ƒç´ ï¼Œåé¢ç›¸åŒçš„ä¹Ÿä¸€å¹¶æ”¾å¼ƒ

private void dfs(int[] nums, int start) {
    res.add(new ArrayList<>(path));
    
    for (int i = start; i < nums.length; i++) {
        // åŒä¸€å±‚å»é‡ï¼šè·³è¿‡ä¸å‰ä¸€ä¸ªç›¸åŒçš„å…ƒç´ 
        if (i > start && nums[i] == nums[i-1]) {
            continue;  // âœ… å»é‡
        }
        
        path.add(nums[i]);
        dfs(nums, i + 1);
        path.remove(path.size() - 1);
    }
}

//åƒä¸‡è®°å¾—è¦æ’åºï¼ä¸æ’åºå°±æ— æ³•æ­£ç¡®å»é‡ï¼
```